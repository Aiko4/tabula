---
output: github_document
header-includes:
   - \usepackage{amsmath}
   - \usepackage{amssymb}
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-"
)
library(tabula)
```

# tabula <img width=120px src="man/figures/logo.svg" align="right" />

[![Build Status](https://travis-ci.org/nfrerebeau/tabula.svg?branch=master)](https://travis-ci.org/nfrerebeau/tabula)
[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/tabula)](https://cran.r-project.org/package=tabula)
[![lifecycle](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)

## Overview

`tabula` provides an easy way to examine archaeological count data (artifacts, faunal remains, etc.). This package includes several measures of diversity, e.g. richness, rarefaction, diversity, turnover, similarity, etc. It also provides matrix seriation methods for chronological modeling and dating. The package make it easy to visualize count data and statistical thresholds: rank/abundance plots, Ford and Bertin diagrams, etc.

## Installation

Install the released version of `tabula` from CRAN:

```{r cran-installation, eval = FALSE}
install.packages("tabula")
```

Or install the development version from GitHub with:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("nfrerebeau/tabula")
```

## Usage

`tabula` provides a set of S4 classes that extend the `matrix` data type from R `base`. These new classes represent different special types of matrix. We denote the $m \times p$ matrix by $X = \left[ x_{i,j} \right] ~\forall i \in [1,m], ~j \in [1,p]$.

* Abundance matrix:
    * `CountMatrix` represents count data, $x_{i,j} \in \mathbb{N}$,
    * `FrequencyMatrix` represents frequency data, $x_{i,j} \in \left[ 0,1 \right]$ and ${\sum_{j}{}^{p}} x_{i,j} = 1$.
* Logical matrix:
    * `IncidenceMatrix` represents presence/absence data, $x_{i,j} \in \lbrace 0,1 \rbrace$.

It assumes that you keep your data tidy: each variable (taxa) must be saved in its own column and each observation (case) must be saved in its own row.

These new classes are of simple use, on the same way as the base `matrix`:

```{r create, eval=FALSE}
# Define a count data matrix
quanti <- CountMatrix(data = 1:100, nrow = 10, ncol = 10, byrow = TRUE)

# Define Ã  logical matrix
# Data will be coerced with as.logical()
quali <- IncidenceMatrix(data = sample(0:1, 100, TRUE), nrow = 10, ncol = 10)
```

`tabula` uses coercing mechanisms (with validation methods) for data type conversions:

```{r coerce}
data("compiegne") # A dataset of ceramic counts

# Define as a count matrix
count <- as(compiegne, "CountMatrix")

# Transform counts to frequencies
freq <- as(count, "FrequencyMatrix")

# Row sums is internally stored before coercion to a frequency matrix
# This allows to restore the source data
count <- as(freq, "CountMatrix")
```

### Analysis

#### Sample richness

```{r richness}
richness(count, method = c("margalef", "menhinick", "berger"), simplify = TRUE)
```

#### Heterogeneity and evenness measures

*Diversity* can be measured according to several indices (sometimes refered to as indices of *heterogeneity*):

```{r diversity}
diversity(count, method = c("shannon", "brillouin", "simpson", "mcintosh", "berger"), simplify = TRUE)
```

Note that `berger`, `mcintosh` and `simpson` methods return a *dominance* index, not the reciprocal form usually adopted, so that an increase in the value of the index accompanies a decrease in diversity.

*Evenness* is a measure of how evenly individuals are distributed across the sample:
```{r evenness}
evenness(count, method = c("shannon", "brillouin", "simpson", "mcintosh"), simplify = TRUE)
```

#### Turnover

The following method can be used to acertain the degree of *turnover* in taxa composition along a gradient ($\beta$-diversity) on qualitative (presence/absence) data.

It assumes that the order of the matrix rows (from $1$ to $n$) follows the progression along the gradient/transect.

```{r turnover}
turnover(count, method = c("whittaker", "cody", "routledge1",
                           "routledge2", "routledge3", "wilson"),
         simplify = TRUE)
```

#### Similarity coefficients

$\beta$-diversity can also be measured by addressing *similarity* between pairs of sites:

```{r similarity}
similarity(count, method = "morisita")
```


### Seriation

```{r seriate-incidence}
# Build an incidence matrix with random data
incidence <- IncidenceMatrix(data = sample(0:1, 400, TRUE, c(0.6, 0.4)),
                             nrow = 20)

# Get seriation order on rows and columns
# Reciprocal ranking method
(indices <- seriate(incidence, method = "ranking", margin = c(1, 2)))
```

```{r permute-incidence, eval=FALSE, warning=FALSE}
# Permute matrix rows and columns
incidence2 <- permute(incidence, indices)

# Plot matrix
library(ggplot2)
plotMatrix(incidence) + 
  labs(title = "Original matrix") +
  scale_fill_manual(values = c("TRUE" = "black", "FALSE" = "white"))
plotMatrix(incidence2) + 
  labs(title = "Rearranged matrix") +
  scale_fill_manual(values = c("TRUE" = "black", "FALSE" = "white"))
```

```{r permute-incidence-plots, echo=FALSE, warning=FALSE, fig.height=3.5}
# Permute matrix rows and columns
incidence2 <- permute(incidence, indices)

# Plot matrix
cowplot::plot_grid(
  plotMatrix(incidence) + 
    labs(title = "Original matrix") +
    ggplot2::scale_fill_manual(values = c("TRUE" = "black", "FALSE" = "white")),
  plotMatrix(incidence2) + 
    labs(title = "Rearranged matrix") +
    ggplot2::scale_fill_manual(values = c("TRUE" = "black", "FALSE" = "white")),
  ncol = 2
)
```

### Visualization

Ranks *vs* abundance plot can be used for abundance models (model fitting will be implemented in a futur release):
```{r rank, fig.height=3.5}
plotRank(count, log = "xy")
```

Spot matrix (no doubt easier to read than a heatmap [^1]) allows direct examination of data (above/below some threshold):
```{r spot, fig.height=3.5}
plotSpot(count, threshold = mean)
```

Bertin of Ford diagramms can be plotted, with statistic threshold (B. Desachy's seriograph EPPM):
```{r seriograph, fig.height=3.5}
plotBar(count, EPPM = TRUE)
```

Matrix plot can produce a visual $\chi^2$ (B. Desachy's matrigraph PVI):
```{r matrigraph, fig.height=3.5}
plotMatrix(count, PVI = TRUE)
```

[^1]: Adapted from Dan Gopstein's original [spot matrix](https://dgopstein.github.io/articles/spot-matrix/).
